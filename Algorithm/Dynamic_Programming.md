# ë™ì ê³„íšë²• (Dynamic Programming)

> í•˜ë‚˜ì˜ í° ë¬¸ì œë¥¼ ì—¬ëŸ¬ ê°œì˜ ì‘ì€ ë¬¸ì œë¡œ ë‚˜ëˆ„ì–´ì„œ  
 ê·¸ ê²°ê³¼ë¥¼ ì €ì¥í•˜ì—¬ ë‹¤ì‹œ í° ë¬¸ì œë¥¼ í•´ê²°í•  ë•Œ ì‚¬ìš©í•˜ëŠ” ë°©ë²•

ë™ì ê³„íšë²•, ì¦‰ DPëŠ” ì‹¤í–‰ ì‹œê°„ì„ ì¤„ì´ê¸° ìœ„í•´ ë§ì´ ì‚¬ìš©ë˜ëŠ” ìˆ˜í•™ì  ì ‘ê·¼ ë°©ì‹ì˜ ì•Œê³ ë¦¬ì¦˜ ì…ë‹ˆë‹¤.  
ê¸°ë³¸ì ìœ¼ë¡œ ë¶„í•  ì •ë³µ ì•Œê³ ë¦¬ì¦˜ê³¼ ë¹„ìŠ·í•˜ì§€ë§Œ ê°€ì¥ í° ì°¨ì´ì ì€ **ë™ì  ê³„íšë²•ì—ì„œëŠ” ìª¼ê°œì§„ ì‘ì€ ë¬¸ì œê°€ ì¤‘ë³µ**ë˜ê³ ,  
 **ë¶„í•  ì •ë³µì€ ì ˆëŒ€ë¡œ ì¤‘ë³µë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.**

![image](https://user-images.githubusercontent.com/37105602/221555327-a7f06cfb-6fd5-4d91-94b2-524b7f3f7022.png)

## ì¡°ê±´
ë‘ ê°€ì§€ ì¡°ê±´ì„ ë§Œì¡±í•´ì•¼ ë™ì  ê³„íšë²•ìœ¼ë¡œ ë¬¸ì œí’€ì´ê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤.  
1. [Overlapping Subproblem](#1ï¸âƒ£-overlapping-subproblems) : ê²¹ì¹˜ëŠ” ë¶€ë¶„ ë¬¸ì œ
2. [Optimal Substructure](#2ï¸âƒ£-optimal-substructure) :  ìµœì  ë¶€ë¶„ êµ¬ì¡°

### 1ï¸âƒ£ Overlapping Subproblems
DPëŠ” ê¸°ë³¸ì ìœ¼ë¡œ ë¬¸ì œë¥¼ ë‚˜ëˆ„ê³  ê·¸ ë¬¸ì œì˜ ê²°ê³¼ ê°’ì„ ì¬í™œìš©í•´ì„œ ì „ì²´ ë‹µì„ êµ¬í•©ë‹ˆë‹¤.  
ê·¸ë˜ì„œ `ë™ì¼í•œ ì‘ì€ ë¬¸ì œë“¤ì´ ë°˜ë³µí•˜ì—¬ ë‚˜íƒ€ë‚˜ëŠ” ê²½ìš°ì— ì‚¬ìš© ì´ ê°€ëŠ¥`í•©ë‹ˆë‹¤.

ì¦‰, DPëŠ” ë¶€ë¶„ ë¬¸ì œì˜ ê²°ê³¼ë¥¼ ì €ì¥í•˜ì—¬ ì¬ ê³„ì‚°í•˜ì§€ ì•Šì„ ìˆ˜ ìˆì–´ì•¼ í•˜ëŠ”ë°,  
í•´ë‹¹ `ë¶€ë¶„ ë¬¸ì œê°€ ë°˜ë³µì ìœ¼ë¡œ ë‚˜íƒ€ë‚˜ì§€ ì•ŠëŠ”ë‹¤ë©´ ì¬ì‚¬ìš©ì´ ë¶ˆê°€ëŠ¥í•˜ë‹ˆ ë¶€ë¶„ ë¬¸ì œê°€ ì¤‘ë³µë˜ì§€ ì•ŠëŠ” ê²½ìš°ì—ëŠ” ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`

### 2ï¸âƒ£ Optimal Substructure
`ë¶€ë¶„ ë¬¸ì œì˜ ìµœì  ê²°ê³¼ ê°’ì„ ì‚¬ìš©í•´ ì „ì²´ ë¬¸ì œì˜ ìµœì  ê²°ê³¼ë¥¼ ë‚¼ ìˆ˜ ìˆëŠ” ê²½ìš°`ë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤. ê·¸ë˜ì„œ íŠ¹ì • ë¬¸ì œì˜ ì •ë‹µì€ ë¬¸ì œì˜ í¬ê¸°ì— ìƒê´€ì—†ì´ í•­ìƒ ë™ì¼í•©ë‹ˆë‹¤.

## ì‚¬ìš©ë°©ë²•

DPëŠ” `íŠ¹ì •í•œ ê²½ìš°ì— ì‚¬ìš©í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì´ ì•„ë‹ˆë¼ í•˜ë‚˜ì˜ ë°©ë²•ë¡ ì´ë¯€ë¡œ ë‹¤ì–‘í•œ ë¬¸ì œí•´ê²°ì— ì“°ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.`  
ê·¸ë˜ì„œ DPë¥¼ ì ìš©í•  ìˆ˜ ìˆëŠ” ë¬¸ì œì¸ì§€ë¥¼ ì•Œì•„ë‚´ëŠ” ê²ƒë¶€í„° ì½”ë“œë¥¼ ì§œëŠ” ê³¼ì •ì´ ë‚œì´ë„ê°€ ì‰¬ìš´ ê²ƒë¶€í„° ì–´ë ¤ìš´ ê²ƒê¹Œì§€ ë‹¤ì–‘í•©ë‹ˆë‹¤.

1. DPë¡œ í’€ ìˆ˜ ìˆëŠ” ë¬¸ì œì¸ì§€ í™•ì¸
2. ë¬¸ì œì˜ ë³€ìˆ˜ íŒŒì•…
3. ë³€ìˆ˜ ê°„ ê´€ê³„ì‹ ë§Œë“¤ê¸°(ì í™”ì‹)
4. ë©”ëª¨(memoization or tabulation)
5. ê¸°ì € ìƒíƒœ íŒŒì•…
6. êµ¬í˜„

## ë©”ëª¨ì´ì œì´ì…˜(Memoization)
>í•œ ë²ˆ ê³„ì‚°í•œ ë¬¸ì œëŠ” ë‹¤ì‹œ ê³„ì‚°í•˜ì§€ ì•Šë„ë¡ ì €ì¥í•´ë‘ê³  í™œìš©í•˜ëŠ” ë°©ì‹

### ì˜ˆì‹œ) fibonaccií•¨ìˆ˜
```
fibonacci(5) = fibonacci(4) + fibonacci(3)
fibonacci(4) = fibonacci(3) + fibonacci(2)
fibonacci(3) = fibonacci(2) + fibonacci(1)

ì´ì²˜ëŸ¼ ê°™ì€ ì—°ì‚°ì´ ê³„ì† ë°˜ë³µì ìœ¼ë¡œ ì´ìš©ë  ë•Œ, ë©”ëª¨ì´ì œì´ì…˜ì„ í™œìš©í•˜ì—¬ ê°’ì„ ë¯¸ë¦¬ ì €ì¥í•´ë‘ë©´ íš¨ìœ¨ì 
```
í”¼ë³´ë‚˜ì¹˜ êµ¬í˜„ì— ì¬ê·€ë¥¼ í™œìš©í–ˆë‹¤ë©´ ì‹œê°„ë³µì¡ë„ëŠ” O(2^n)ì´ì§€ë§Œ, ë™ì  ê³„íšë²•ì„ í™œìš©í•˜ë©´ O(N)ìœ¼ë¡œ í•´ê²°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.



## êµ¬í˜„ ë°©ì‹
ë™ì  ê³„íšë²•ì˜ êµ¬í˜„ ë°©ì‹ì—ëŠ” ë‘ ê°€ì§€ ë°©ë²•ì´ ìˆìŠµë‹ˆë‹¤.
- **Top-down** : í° ë¬¸ì œë¥¼ ì‘ì€ ë¬¸ì œë¡œ ìª¼ê°œì–´ í‘¸ëŠ” ë°©ë²• (ì¬ê·€í•¨ìˆ˜) 
- **Bottom-up** : ì‘ì€ ë¬¸ì œë¶€í„° ì°¨ê·¼ì°¨ê·¼ êµ¬í•˜ëŠ” ë°©ë²• (ë°˜ë³µë¬¸)

> Bottom-up ì€ í•´ê²°ì´ ìš©ì´í•˜ì§€ë§Œ, ê°€ë…ì„±ì´ ë–¨ì–´ì§  
Top-downì€ ê°€ë…ì„±ì´ ì¢‹ì§€ë§Œ, ì½”ë“œ ì‘ì„±ì´ ì–´ë ¤ì›€


## ğŸ“Œì˜ˆì œ (Baekjoon)
[1ë¡œ ë§Œë“¤ê¸°](https://www.acmicpc.net/problem/1463)
>ë¬¸ì œ
<img width="1057" alt="image" src="https://user-images.githubusercontent.com/37105602/221562187-88391cfb-d63c-439f-b8e8-507b82985e62.png">

>í’€ì´

[Overlapping Subproblem](#1ï¸âƒ£-overlapping-subproblems)ì™€, [Optimal Substructure](#2ï¸âƒ£-optimal-substructure) 2ê°€ì§€ ì¡°ê±´ì„ ëª¨ë‘ ë§Œì¡±í•˜ë¯€ë¡œ,  
`DP`ë¥¼ ì´ìš©í•˜ì—¬ í’€ì´ê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤.

ì¼ë‹¨, 2ì™€ 3ìœ¼ë¡œ ë‚˜ëˆ„ì–´ ë–¨ì–´ì§€ì§€ ì•ŠëŠ” ê²½ìš°ëŠ” ë¬´ì¡°ê±´ 1ì„ ë¹¼ì•¼ í•˜ê¸° ë•Œë¬¸ì—

dp[i] = dp[i - 1] + 1ì„ í†µí•´ íšŸìˆ˜ë¥¼ +1 ì¶”ê°€ í•©ë‹ˆë‹¤.

ê·¸ë¦¬ê³ ë‚˜ì„œ, dp[i]ê°€ 2 ì™€ 3ìœ¼ë¡œ ë‚˜ëˆ„ì–´ ë–¨ì–´ì§€ëŠ” ê²½ìš°ì—ëŠ”

1ì„ ë¹¼ëŠ” ê²ƒ ë³´ë‹¤ ë‚˜ëˆ„ì–´ ë–¨ì–´ì§€ëŠ”ê²Œ í›¨ì”¬ ì´ë“ì´ê¸° ë•Œë¬¸ì—

min(dp[i], dp[i//2]+1)ì„ í†µí•´ ìµœì†Œê°’ì„ ì„ íƒí•˜ë©´ ë©ë‹ˆë‹¤.

### ì½”ë“œ (Python) - Bottom-up(ë°˜ë³µë¬¸)
```Python
import sys
input = sys.stdin.readline

n = int(input())

dp = {
  0 : 0,
  1 : 0,
}

for i in range(2, n + 1):
  dp[i] = dp[i - 1] + 1

  if i % 2 == 0:
    dp[i] = min(dp[i], dp[i // 2] + 1)

  if i % 3 == 0:
    dp[i] = min(dp[i], dp[i // 3] + 1)

print(dp[n])
```
### ì½”ë“œ (Python) - Up-down(ì¬ê·€í•¨ìˆ˜)
```Python
import sys
input = sys.stdin.readline

num = int(input())

dp = {
  0 : 0,
  1 : 0,
}

def rec(n):
    if n in dp.keys():
        return dp[n]
    if n % 3 == 0 and n % 2 == 0:
        dp[n] = min(rec(n//3) + 1, rec(n//2) + 1)
    elif n % 3 == 0:
        dp[n] = min(rec(n//3) + 1, rec(n-1) + 1)
    elif n % 2 == 0:
        dp[n] = min(rec(n//2) + 1, rec(n-1) + 1)
    else:
        dp[n] = rec(n-1) + 1
    return dp[n]

print(rec(num))
```

## Reference
https://velog.io/@polynomeer/%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95Dynamic-Programming